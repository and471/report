\documentclass[a4paper, titlepage]{article}

\usepackage[english]{babel}
\usepackage[utf8x]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{fullpage}
\usepackage{parskip}
\usepackage{setspace}
\usepackage[justification=centering]{caption}
\usepackage{subcaption}

\linespread{1.1}

\title{Visualisation AppStore \\ \vspace{10pt}
\textit{\large Integrated platform for visualistion submission, scheduling and visualisation wall playout} \\ \vspace*{-5pt}
\textit{\large Commissioned by Imperial Data Science Institute}}

\author{Andrew Higginson\\ Bryan Liu \\ Emma Hulme \\ Jia Guang Choo \\
        Thomas Taylor-Hall \\ Timothy van Bremen \\\\ 
        Department of Computing \\ Imperial College London \\\\ \textit{Supervised by:} \\
        Prof. Yi-ke Guo \\ Dr. David Birch}

\date{January 2015}

\begin{document}
\maketitle


\newpage
\pagenumbering{roman}
% -- Executive Summary
\Large
\textbf{Executive Summary}

\normalsize

Society is becoming more technological and more environmentally friendly - no one is interested in 
flyers or posters any more. We want interactive screens, video clips, digital adverts and 
visualisations everywhere we walk.

The newly refurbished William Penney building will house multiple projectors, displaying information
on floor-to-ceiling glass to passers-by on the Sherfield Walkway. We've developed a system for 
submisson, moderation and scheduling for visualisations and adverts to be displayed on the side of 
the building. 

Companies and private users can log in to submit videos, images and visualisations in the form of 
adverts, event publicity and decoration. Administrators are then tasked with the moderation and 
scheduling of submitted content, which is displayed by our software running on a dedicated machine
hooked up to the projectors. 

Got an event at 1 o'clock on Monday the 12th of Jan? Submit it via our web application and ask for 
it to be scheduled at that time via the flowing one-page site. 

Unlike other systems around the college, we have built our cross platform software to hide all 
implementation details from the screen, and make sure no nasty error messages or windows command 
prompts are shown.




% ---

\newpage
% -- Table of Contents
\tableofcontents
\listoffigures
\listoftables
% ---


\newpage
\pagenumbering{arabic}
\section{Introduction}

As part of the renovation of the William Penney Building, the part of the building facing onto the Sherfield walkway will be undergoing major changes in order to further promote the home of the Imperial Data Science Institute. These changes include mounting an 84 inch 4K touch panel adjacent to the building's entrance, as well as replacing the existing small windows with floor to ceiling glass panel, onto which content can be projected to the hundreds of students, teaching staff and visitors who pass by everyday via eight HD projectors.

\begin{figure}[h!]
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{./intro/Entrance.jpg}
  \caption{Entrance}
  \label{fig:sub1}
\end{subfigure}
\begin{subfigure}{.5\textwidth}
  \centering
  \includegraphics[width=.9\linewidth]{./intro/External.jpg}
  \caption{Whole exterior (facing Sherfield Walkway)}
  \label{fig:sub2}
\end{subfigure}
\caption{A render of the proposed changes to William Penney Building}
\label{fig:intro_WPrender}
\end{figure}

Our project comes in 3 parts. The first is to develop playout software which will display content on these large panels, making use of the panels either as several discrete screens, or grouping panels to form large continuous surfaces. The second is to develop a scheduling component, allowing administrators to select and schedule the content shown on these panels. The third is to create an online ``store''/catalogue where content to be shown on the panels can be viewed, submitted and moderated.

\subsection{Motivation}

\subsubsection{Imperial Data Science Institute: Improved Recognition}
The \textbf{Imperial Data Science Institute} \textit{"conducts research on the foundations of data science. Its mission is to foster the development of advanced theory, technology and systems that contribute to the state-of-the-art in data science and big data, notably by funding data-driven research projects and by organizing seminars. The Institute empowers Imperial College and its partners to collaborate in the pursuit of world-class data-driven innovation."}\footnote{http://www3.imperial.ac.uk/data-science}

Despite the exciting world leading innovation happening inside the William Penney Building, its bland looking exterior does not allow passers-by to experience any of the work happening inside. The building is situated on the Sherfield Walkway, one of the busiest parts of the South Kensington campus, due to its centrality in the campus, and also its proximity to the main eating facilities of the campus (the Junior and Senior Common Rooms) and several faculty buildings (Sherfield Building, Huxley Building, ACE Extension). 

Furthermore, the work of the Data Science Institute is unique in that it is very easy to display and present the results of research, in a way that passers-by, regardless of their own areas of studies, can understand, in the form of data visualisations. Many such visualisations already exist and the new projection panels, combined with the large daily footfall, provide a perfect way to increase awareness of the Data Science Institute on campus, and to showcase its latest world-leading research.

\subsubsection{Development Team: Skills Development}
We decided to take on this project as we found the scope of the project exciting, the opportunity to revisit and perfect our skills in areas previously explored (such as creating a web application), the opportunity to make use of our more JMC mathematical orientated knowledge (the algorithms used for scheduling) and finally the opportunity to explore new areas of software engineering we hadn't yet experienced in our studies (a GUI application with a large focus on aesthetics and reliability).

Furthermore, the project lent itself very well to be divided into 3 discrete parts (the playback software, scheduling, and visualisation catalogue) and so we felt it would be easy to delegate work between the 6 group members, even splitting into smaller subgroups, each working on a different part.

Finally, we were excited to be able to work on something that we may see and come into contact with everyday - \textit{a rare opportunity}.

\subsection{Objectives} \label{sec:intro_objectives}

From the initial project specification, and discussion with our supervisor(s), we started to extract features/objectives we wanted to achieve. We then added these to our Trello Board (see section \ref{sec:projman_devprocess}) so that throughout development, we had these high-level goals in mind. 

These however did not remain completely static and would change/be extended, based on subsequent discussions with our supervisor(s), as we ``pivoted'' towards the best solution.

\begin{figure}[h!]
  \centering
    \includegraphics[width = 0.5\textwidth, trim = 0 0.5cm 0 1.2cm, clip]{./intro/userreq.jpg}
  \caption{Illustration of initial project specification}
  \label{fig:intro_userreq}
\end{figure}

\subsubsection{Primary Objectives} \label{sec:primary_objectives}
\begin{itemize}
\itemsep-1mm
\item Users can view visualisations through a web interface
\item Users can submit content to be considered for playback
\item Administrators can moderate submitted content
\item Administrators can schedule content to be played back
\item Content should be served for playback by an intelligent algorithm
\item Scheduling component should be secure from outside attacks
\item Playback system should be robust
\end{itemize}

\subsubsection{Secondary Objectives} \label{sec:secondary_objectives}
(Derived from primary objectives and subsequent discussions)

\begin{itemize}
\itemsep-1mm
\item System should rely on Imperial credentials for authentication, by should allow external users to request access
\item Users should be able to ``like'' content items and comment on them
\item Allow submitting of both advertisements and visualisations
\item Allow submitting of different formats - images, static web content and videos
\item Scheduling should be flexible, but require as little input as possible
\item There should be some guarantee for the amount of time a content item is shown, given its priority
\item Playback system should be aesthetically smooth and not reveal any implementation through its appearance
\item Playback system should not be tied to any specific screen configuration or platform and should intelligently use the displays at its disposal
\item Content can be played back over multiple screens
\end{itemize}


\subsection{Stakeholders}

Shortly after receiving the project specifications, we identified the stakeholders in our project, their relative importance, and their requirements.

\subsubsection{Administrators}
These are members of staff inside the Data Science Institute who would moderate submitted content, and decide which content items should be scheduled for playback. They require both the moderation and scheduling processes to be as easy as possible, and suited to them, as they are processes which will be repeated very often.

As these users will be using the system most, and the components they interact with are not precisely defined in the specification, their opinion throughout the development process is very important.

\textbf{Requirements}
\begin{itemize}
\itemsep-1mm
\item Approve or reject submitted content
\item Choose content to be selected for playback, along with relative priorities and times in which to be shown
\item Gain some idea of the when the user wants submissions to be played
\end{itemize}



\subsubsection{Users of visualisation catalogue (submitters)}

These are users of the web application component of our system. They should be able to view those visualisations which have been approved, and find out more about a certain visualisation and ``like'' and comment on a visualisation. This should be done via a modern looking, smooth interface (to reflect the cutting edge Data Science Institute) and they should be able to do so on any device of their choosing (i.e. mobile, tablet or through a traditional desktop interface).

Furthermore they should be able to submit content of their own, which after moderation, may be selected for playback. This should be easy to do, supporting a wide variety of formats, and should be done through a slick interface which the user should be confident will get their submission seen.

\textbf{Requirements}
\begin{itemize}
\itemsep-1mm
\item View moderated content and interact in a visual and intuitive way
\item ``Like'' and comment on content items
\item Submit content to be selected for playback
\item Supply additional information on submission e.g. scheduling preference(s)
\end{itemize}

\subsubsection{Users of playback software (passers-by)}

These are students, members of staff and visitors who may pass by or enter the Data Science Institute and see the content projected onto the visualisation panels. They interact with the system in a fairly distant way, and their interaction is fairly well defined - they view the projected content.

Whilst they don't need a large amount of input through the development process, we did identify that how the interact should be aesthetically smooth. They should see content projected correctly, with seamless transitions between content items, and should never have any implementation revealed to them (i.e. an error causing the underlying system to be revealed).

%I removed the 'like' requirement here as that was more of an extension
\textbf{Requirements}
\begin{itemize}
\itemsep-1mm
\item View projected content
\item See an ever-changing screen
\end{itemize}


\subsection{Achievements}
We have experimented successfully with new technologies such as AngularJS and Python using the GTk 
library. Most of our previous applications have not contained a GUI, so implementing the playout
system has been a substantial achievement. Also, as it was a requirement for the playout software 
to be cross platform, we had to change our way of thinking when implementing. We had to ask ourselves:
``How would we implement this feature?'' and ``Will this work on Linux and Windows systems?''. This 
style of development will help us for future projects.

Away from the technical side of development, we have achieved a good example of an ``Agile'' development
process encorporating multiple features of different development styles, according to our preference. 
We can measure this by looking at our Trello board and meeting notes, and comparing our work to 
previous project cycles. As a group we all stated that we enjoyed working on this project and would 
definitely use the ``Agile'' methodology in future. 

The project has also allowed us to learn how to manage time effectively, especially when juggling 
other academic commitments like lectures and exams. 

As we have achieved most of the requirements (with the remaining needing to be finished off), the 
project was quite successful. The application looks proffesionally designed and implemented.

\newpage
\section{Project Management}

\subsection{Task Estimation \& Planning}

\subsubsection{Practical Constraints}
The group is acutely aware that with Computing examinations being held at the
end of term, we could only practically carry out development work until the
first week of December. Furthermore, commitments in other courses mean that 
each team member is only able to devote around 16-20 hours per week to
the project. As a group, we allowed some leeway for each task in case we run into technical errors. If this was the case, we communicated and came up with a solution if necessary.

In light of these constraints, we decided to commit to the following:
\begin{enumerate}
  \item \textbf{To maintain a one-week iteration}: this allows the development team to
        obtain maximum possible feedback from our supervisor, who act as our client.
  \item \textbf{To strictly adhere to the original project scope}: while we believe the
        current scope is manageable, we would reject time-consuming items which
        are out of scope before a minimal working system, as specified in section \ref{sec:intro_objectives}, is implemented.
\end{enumerate}

\subsubsection{Release \& Iteration Plans}

\begin{figure}[h!]
  \centering
    \includegraphics[width = 0.99\textwidth, trim = 0 3.8cm 0 0.8cm, clip]{./projman/timeline.jpg}
  \caption{Project plan with timeline}
  \label{fig:projman_timeline}
\end{figure}


Taking account of the current project scope, the resultant plan and timeline shown in figure 
\ref{fig:projman_timeline} is a
combination of the plan for subsequent iterations and the release plan, further elaborated in tables 
\ref{tab:projman_rplan} and \ref{tab:projman_iplan}. Each post-it note either represents a 
concrete task to be completed during an iteration (towards the left), or
high level themes to be implemented (towards the right). Each line segment at
the bottom represents an iteration ending on Thursday, when the development
team will meet with the client.

\begin{table}[h!]
  \begin{center}
  \begin{tabular}{c | c | c}
     \textbf{Academic Week (ending date)} & \textbf{Iteration/Sprint} & \textbf{Feature to Release} \\ \hline
     3 \& 4 (30 Oct) & 1 & Infrastructure setup \\
      & & Internal login \\
     5 (6 Nov) & 2 & Access request for externals \\
      & & Visualisation submission \\
     6 (13 Nov) & 3 & Comment/view existing visualisation \\
      & & Admin moderation/ approval \\
     7 (20 Nov) & 4 & Scheduling \\
     8 \& 9 (4 Dec) & 5 \& 6 & Playout \\
  \end{tabular}
  \end{center}
  \caption{Release plan}
  \label{tab:projman_rplan}
\end{table}

\begin{table}[h!]
  \begin{tabular}{c | c | c | c }
    \textbf{Iteration} & 1 & 2 & 3 \\ \hline
   \textbf{Tasks} & Front-page \& Grid view & Individual vis$^\textrm{n}$ page template & View/controller hookup\\
      & Docker setup & Configure uploading library & (existing visualisations)\\
      & Hello-world server & Models \& RESTful APIs& Moderation (controller actions)\\
      & Jenkins setup & (for users and visualisations)& Default vis$^\textrm{n}$ seeding\\
      & Kerberos login& Vis$^\textrm{n}$ BG colour extraction & Model extension (comments)\\
      & ... & ... & ...
  \end{tabular}
  \caption{Tasks to be completed for each iteration (partial)}
  \label{tab:projman_iplan}
\end{table}


Estimates on time required for the tasks were based on their relative size and
time taken for us to complete similar ones in the past. For example, some of us
have implemented a College (Kerberos) Login System well within a week, thus if
it is a size M, we inferred that the team (now double the size) is capable of 
fitting two size M tasks within an iteration. For larger system modules, we
assign a longer period specifically for that task: we expected that the scheduling
system (size L) and the entire playout system (size XL) would take us one and
two iteration(s) respectively.


\subsection{Group Organisation} \label{sec:projman_group}

\subsubsection{Team Formation}
After we established the requirements of the project, each group member stated
which part of the project they would like to work on. We found that there was a
good split of two people (Andrew \& Emma) that wanted to work on the frontend,
two (Thomas \& Timothy) on the backend server code, and two (Bryan \& Jia Guang)
focusing on database and scheduling.

Although this is a good split to initiate work, we realised that the frontend 
aspect of the project may require more work approaching later iterations.
In addition, we expect that the server code and database should be fully 
implemented within the first four iterations, only requiring minor fixes thereafter.

Therefore, we decided that two people from the backend would move on to creating
the playout software on the dedicated computers; one person would help with the
frontend and the remaining person would apply small fixes and refactors to the
existing server/database code.

\subsubsection{Team Coordination}
% TODO: Chatley: Think about how to synchronise FE and BE work, what if one gets ahead/behind?
TODO

After forming the sub teams, we decided that Bryan and Andrew would be the two respective team 
leaders for the server/database team and frontend team respectively. This way, they could delegate 
tasks to specific members at specific times, and give deadlines for particular features - formalised 
via our Trello board.

We also coordinated our work by communicating on Facebook chat. Here we could ask how a particular 
feature was coming along and also organise pair programming in labs. This was particularly useful as 
the whole group could see development progress at the same time. Also, the chat allowed us to use our 
time effectively - if a member needed a particular feature before he/she could start work, then they
could implement a different feature in the mean time. 

Towards the end of the project, we used the issue tracker on Gitlab to let the group know of small bugs.
Although these could be assigned to a specific member, we left them open to the group, so an
appropriate team member could address the issue. 

\begin{figure}[h!]
  \centering
    \includegraphics[width = 0.99\textwidth]{./projman/issue_page.png}
  \caption{Small section of the issue tracker on Gitlab}
  \label{fig:projman_issues}
\end{figure}




\subsubsection{Preference on Technologies}
We also asked each group member if there were any specific technologies they 
would like to use, as we realise this project should also be an opportunity to explore new
technologies. After collating these, the member who suggested a technology was then 
tasked with researching more about it, and finding out if it met the requirements of the project.
The member will also be responsible to implement the features with the technology should it be
deemed fit.



\subsection{Development Methods} \label{sec:projman_devprocess}
The team has agreed to adopt a mixture of agile development methodologies to
ensure our practical need and assist the group's working flow.

\subsubsection{General Project Management}

For project management, we generally follow the Scrum method, adopting the
following characteristics:
\begin{itemize}
  \item \textbf{Roles}: We see Dr. David Birch, our supervisor, as the \textit{Product Owner}
        who provide ideas and feedback for the development. At the same time,
        the team have agreed that Andrew should assume the role of
        \textit{Scrum Masters} to facilitate work.
  \item \textbf{Ceremonies}: Upon the initial meeting, we have established a
        meeting with David each Thursday to review our previous sprint 
        and plan our next sprint. We are to hold a development team
        meeting every Monday (figure \ref{fig:projman_scrum}) to update each other 
        on our progress and review work done in past sprints.
  \item \textbf{Artefacts}: We keep our product backlog and iteration backlog on
        Trello as part of our project tracking mechanism (more details
        available in section \ref{sec:projman_tracking}).
\end{itemize}


\begin{figure}[h!]
  \centering
    \includegraphics[width = 0.99\textwidth, trim= 0 0 0 3cm, clip]{./projman/scrum.jpg}
  \caption{Half-weekly ``scrum'' (development team meeting).}
  \label{fig:projman_scrum}
\end{figure}

\subsubsection{Technical Practices}

We also integrate a few technical practices inspired by Extreme Programming:
\begin{itemize}
  \item \textbf{Pair Programming}: As mentioned in section \ref{sec:projman_group}, we sorted
        ourselves into three pairs, focusing on frontend (FE), backend (BE) and database (DB) work.
        Such a practice allows continuous development on all divisions without
        being affected by instances in which a member is required to temporarily shift his or her
        focus from the project to other coursework/tests. All members are open to team
        with different members for different tasks, though it turned out members have similar
        preference and usually end up in the same pairs for different tasks.
  \item \textbf{Test-driven Development}: During development, we always write unit and system tests prior to conducting the actual implementation. This ensures individual features are working as expected before we move on to the next feature.

\end{itemize} 

\subsubsection{Project Tracking} \label{sec:projman_tracking}

\begin{figure}[h!]
  \begin{subfigure}{0.5\textwidth}
    \centering
    \includegraphics[width = 0.9\textwidth]{./eval/trello-columns.png}
    \caption{Priority columns on our Trello board}
  \end{subfigure}
  \begin{subfigure}{0.5\textwidth}
    \centering
    \includegraphics[width = 0.9\textwidth]{./eval/trello-due-date.png}
    \caption{Setting a due date for a particular task}
  \end{subfigure}
  \caption{Using Trello for project tracking}
  \label{fig:eval_trello}
\end{figure}

Finally, to keep track on the group's progress, we use an electronic task
board on Trello (see figure \ref{fig:eval_trello}). Here we can assign ourselves (and others) specific tasks and a general due date. Trello allows us to see what the other members of the group are doing and when a feature is expected to be completed. We can also easily add photos and checklists to see how the project is forming. We decided to use Trello as a physical story-board is not feasible. As well as Trello, we were constantly communicating personally in labs, online via messaging services (mainly Facebook Messenger), and regular stand-ups in a meeting room.

We chose to incorporate this into our way of working, as one of the team members, Andrew, had been involved in projects using Trello, and found it very useful to visualise the work being done on a project.


\subsection{Development Tools}
We have also employed a variety of tools in parallel of our technologies used
in main implementation, illustrated in figure \ref{fig:projman_devtools}, to
enhance our performance.

\begin{figure}[h!]
  \centering
    \includegraphics[width = 0.99\textwidth]{./projman/devtools.pdf}
  \caption{Development methods and tools utilised in project.}
  \label{fig:projman_devtools}
\end{figure}

\subsubsection{Unified Development Envorinment} \label{sec:projman_devenv}
%Docker to reproduce dev environment
%Work on own vms in cloudstack within docker container
% Good for testing features away from master

% VM
% Docker

In a group project last year, the backend team had to rely on frontend not in a broken state to ensure a 
particular feature was working. Utilising the newly available CloudStack from the department,
we are able to create a number of virtual machines (VMs) for each feature while it is in development,
and have multiple copies of the web server running from each VM respectively.

While the VM comes nearly for free, they might come with slightly different specification,
which might cause discrepancies further into development. After a lecture on deployment techniques, the group decided to use Docker. Docker allows us to quickly set up standardised VMs (containers), installing any dependencies we need automatically. Although it may be a steep learning curve at the start of our project, it proves that Docker saved us a lot of time, 
for instance ensuring all supporting libraries exist in local VM.

To further speed up development process, we have also written a number of automated scripts
to build Docker images (templace for a container VM), as well as starting and stopping the
webserver when called.

\subsubsection{Version Control}
The team has decided to continue using Git as our version control system, as all of us have had
at least two years of relevant experience from previous projects and laboratory work. Furthermore,
Git is supported by multiple OS platforms with minimal configuration (e.g. end-of-line CRLF/ LF conversions),
allowing one to continue their work should a linux machine, for example, is not available.

As usual, all of our code (including the scripts mentioned in \ref{sec:projman_devenv}) 
are stored in a group git repository on the department's GitLab server. Instead of naming branches under team members'
name and working under it individually for the entire project span, we have decided to use branches with a short lifetime.
Each minor feature is implemented on it's own branch, and the master branch is only used for merging in features for release
after being tested locally on its own branch and associated local VM (see section \ref{sec:projman_tdd}).
Such practice makes it easier for different team members, under pair programming, to work on the same feature.
It also makes it easier for the team to backtrack and locate the bug should any problem arise by checking a small number of commits on that particular branch.

Moreover, with meaningful yet concise commit messages, wiki residing in repository and issues, we can effectively
communicate with each other what we have done along with updating our task-board
on Trello and sending messages on Facebook Messenger.


\subsubsection{Test-driven Development} \label{sec:projman_tdd}
With Ruby on Rails being our choice of implementation language (refer to section \ref{sec:impl_RoR}),
RSpec is inevitably the obvious choice for testing server codes.
While it is nicely integrated with Ruby on Rails, with test templates automatically
generated along with new code segments (models and controllers);
tests written with RSpec is highly human-readable and thus
easing the difficulty in maintainence as the tests themselves are already
decent documentation of our implementation.

We also have an automated script to run all written tests in a seperate
environment (Docker container) without affecting the webserver, minimising
the disruption to the server's normal operation during development.


% RSpec - Nice integration with RoR
% Failed test - imp - passed test - (refactor) cycle
% Another automated script to run all test in seperate Docker container

\subsubsection{Continuous Integration \& Build Promotion}
% Jenkins installed on a release vm
% Tests code every time we push to master by pulling it
% Tells us quickly if something is wrong

While it is cumbersome to manually stop, test and restart the server
everytime we implement a feature or provide a fix, we have
included a Jenkins instance in our release virtual machine to automate
the code integration and deployment process, allowing us to focus on
development.

Our Jenkins instance is equipped with a GitLab hook: upon any team member's
commit towards the master branch of the project git repository, the hook would
automatically execute a short script which pulls the updates, runs the tests
on the updated code and integrates the updates. If something went wrong,
Jenkins would notify us immediately and we could look at the issue and get
it resolved as soon as possible.

This feature also meant that our supervisor, David, could look at the release VM 
for the most up to date version of our web application. 

\newpage
\section{System Design and Implementation}
\subsection{User Interface Design}

As mentioned previously, the design for the playback software was already pretty well defined, content is shown with little/no UI chrome, and hence we didn't have to consider this component too much in terms of user interface design.

On the other hand, the Visualisation Catalogue and Scheduling components had very few constraints in the initial specification, and so we quickly set to work trying to decide on the overall design of our project.

\subsubsection{Scheduling}
Using skills we acquired in a previous relevant module, Human Centered Design, we decided to take a design-led approach to our project, which involved us sitting down with the important stakeholders in the final product, and finding out what they required from the product. As detailed above, this therefore took the form of meetings with the future 'Administrators' who would use the product to schedule content. We learned from discussions with them, that whilst they were happy for us to take the aesthetic design in any direction we wanted, the most important aspect to them would be the ease-of-use of the scheduling component. Their requirements were:
\begin{itemize}
\item Content should be able to be scheduled on a high level - the minute-by-minute timing should not be of concern to an administrator
\item There should be some notion of weighting of different content item, and some associated guarantee about display time (e.g. to satisfy and external client request)
\item Scheduling should be flexible, such that an administrator can override scheduling at any time
\item If no content has been scheduled at a particular time, the system should gracefully react to this, by playing some default content
\item There should be some way of easily repeating a content schedule previously created
\end{itemize}

From these requirements and subsequent discussions, we decided on the following 'high-level' design for scheduling.

\textbf{Timeslots} are 'windows' which have a start and end time. Administrators create timeslots, and then assign content items which should be played within a timeslot. In a certain timeslot, a content item has an associated \textbf{priority}, an integer between 1 and 10 (inclusive). This priority is using by the scheduling algorithm to calculate the durations a content item should be shown, where the time a content item is shown is relatively proportional to its priority. For example, if we have two content items in a certain timeslots, with priorities 1 and 2, they will be shown for $\frac{1}{3}$ and $\frac{2}{3}$ of time time (respectively).

An overriding mechanism is actually a side-effect of this design - if an administrator only wants one content item to be shown, they simply only assign one content item to a timeslot. This design allows administrators to quickly and easily assign content for different times of the day and days of a particular week, designating as much work to our algorithm as we can whilst maintaining flexibility.

\subsubsection{Overall Design Principles}
Having settled on this high-level design, we then start to drill down on what we wanted our project to look like in a more concrete way.

As mentioned previously, we wanted users to be able to access and use the Visualisation Catalogue web application on whichever device they wanted, with little or no limitations between platforms. We found that Google's Material Design\footnote{http://www.google.co.uk/design/spec/material-design/introduction.html} principles matched the way we wanted to take our product, and they allowed us to design one interface, which adapted to the user's chosen device - a cohesive approach which didn't offer some 'lesser' interface based on device. Material Design's card metaphor also seemed to match perfectly with the concept of a visualisation or advert and so we decided to base the interface around them.

We began by sketching mockups of the ideas we had around the main site's interface, however due to already haven chosen to follow the Material Design guidelines, once we had agreed on basic ideas, we quickly migrated to more specific 'mockups'. We used Inkscape to create these, and presented them to our supervisors, before we started heavily implementing the UI, as a final check. We began with the main 'Visualisations View' and then migrated to the adminstrator-only parts of the site.

The interface provides navigation via a side-menu, displayed whenever the user clicks the top-left 'hamburger' icon. Only the parts of the application the current user can access are shown (i.e. only administrators are shown the Schedule and Moderate menu items). The side-menu also alows access to the sign-in and out functionality of the web application.

The 'Visualisations view' adopts a masonry-like grid layout, showing the approved visualisations that have been submitted. Visualisaitons can be filtered from this view via the search entry at the top right, or via the filters located in the side-menu. The search entry at the top right actually provides search for many other pages, and its behaviour depends on the current page.

A user can click on a visualisation card to access the 'View visualisation' page which maintaining the card metaphor, provides more information, such as a full description, details about the user which submitted it, as well as revealing comments made about the visualisation, and allowing the user to 'like' or comment on it.

Finally, the sign-in functionality is contained in the 'Sign in view', which allows a user to log-in with their Imperial username and password. By including the Imperial logo, we hope to reassure user's that their credentials are safe. It is from this page that external users may also request access.

As mentioned before, the elements of the Material Design guidelines lend themselves very well to many devices profiles, and by using a responsive grid system, the design between desktop, tablet and mobile is essentially the same, the only difference being elements which would be horizontally adjacent on the desktop are often vertically adjacent on mobile/tablet.

Moving onto the parts of the application only visible and usable by adminstrators, first we have the 'Moderate view'. This is a fairly simple interfae comprised of two list views, allowing an adminstrator to quickly and easily see both external users and submitted content which needs to be moderated, in an interface that scales very well.

Moving onto the 'Schedule view', this is perhaps the most complex part of the application, however we tried to focus on making the interface both discoverable, and quick to use (a requirement we identified previously).The main part of this interface is the timeline, which contains section's for each day of the current week, and allows a user to scroll horizontally to move back and forward throughout the day. The user can also use the week selector located above it, to move forward and backward, weeks at a time. The interface automatically scrolls to the most relevant period within a day, 9am, and the timeline allows a user to add and delete timeslots, by double-clicking and pressing DEL respectively. The intelligent timeslot-editing control allows timeslots to be dragged around and resized, but is aware of conflicts and actively tries to avoid them. For examples, when resizing, timeslot edges snap to other timeslot edges, and when a conflict is created, the user is notified via a toast\footnote{A small onobtrusive notification, shown at the top of the screen}, and the conflicting timeslots remain highlighted until they no longer interfere.

In order to assign content to a timeslot, the user must double click on a timeslot, at which point they are taken to the 'Timeslot editing view'. Here they are able to assign and unassign content to that timeslot via a drag-and-drop interface, which we felt was the most natural approach. One content has been assigned to the timeslots, but selecting the content item, a user is then able to edit properties associated with the content item in that timeslot, such as priority and the number of screens it should be shown on. We felt it was important that during this stage, the adminstrator should have information that may help them, situated directly within this interface, and so we took the approach that the top section contains admin-editable properties, and the bottom section contain user-provided fields which may be useful.

Because a mistake made in this interface would not consittate a large amount of time to fix, we decided to make all actions in the scheduling interfaces immediate (i.e. there is no secondary Save action once actions have been made). This allows an administrator to very quickly perform the required actions to schedule content for playback.


\subsection{Implementation Tools}

\subsubsection{Front-end}

Given the frontend team's previous experience with Ruby on Rails standard web applications, enhanced with jQuery, they decided to take this opportunity to experiment with new technologies, as well as use their existing expertise to produce a professional looking application. They chose to use AngularJS,so they could use its useful features such as:
\begin{itemize}
\item Two-way data binding
\item Simple RESTful resource integration
\item Smooth one page experience
\item Custom templates and directives
\item Clear separation of controller and view logic
\end{itemize}

We also learned to appreciate AngularJS's 'declarative style' - being able to see the \textbf{behaviour} of the application by reading the HTML code. This was particularly useful at later stages, as it meant that when different members of the group were working on different parts of the frontend code, it was very easy to quickly see what another member had done, without delving too deep into the code they'd written.

Apart form the controller logic, which was written in AngularJS and jQuery, we also use SASS to write our style sheets, allowing us to use variables, nested rules etc. which became useful as our codebase began to grow. We also used Bootstrap as it allowed us to get started with the frontend implementation very quickly, however apart from its responsive grid capabilities (which we used to provide one experience regardless of platform) we moved away from its preset styles, as they did not match the aesthetic direction we wanted to take.

Because all the frontend controller logic was implemented on the client-side, we only used Rails to serve our Javascript, CSS and HTML (template) files. There was little to no logic for the frontend contained in Ruby code, all the interaction between server and client-side was done via our RESTful JSON API. This allowed us to use AngularJS's full capabilities, and presented a few issues which we were able to easily overcome (the main being authentication on the client side, which we solved via an OAuth-like method with authentication tokens).


\subsubsection{Back-end: Initial Implementation - Flask (Python) \& MongoDB}

During the inital phases of our project, we decided on which tools/technologies to use based on our personal preference. For the backend, we decided to use Python with Flask. Members of our team had previously used Ruby on Rails and Python with Django, so we decided to use Flask for interest and 
learning purposes. To make sure Flask was suitable, the backend team spent time researching additional 
modules that would allow us to implement future features.


% Advantage of MongoDB - fast read, scalable, JS-like (easy FE adaptation)
As Bryan and Jackie were more interested in the database side, they chose to use MongoDB as a NoSQL
solution. Again, this was based on interest. We saw that MongoDB is  especially helpful especially in 
early development stage when the schema is not well-defined, as MongoDB is flexible with 
document-oriented, dynamic schemas. Moreover, we believe MongoDB's ability in supporting fast read and 
scalability would be beneficial to the project in long-term. Bryan used time at the beginning of the 
project to check that Flask was compatible with MongoDB and found it is possible with the library 
\texttt{Flask-PyMongo}.


% Problems - broken kerberos adapter, (changed from flask as we were getting stuck - consulted with David)
After about a week of usage, we found that there had been lots of small problems in development, as 
well as Flask being one of the lesser-documented and feature-filled frameworks. After experimenting 
with a Kerberos authentication module for Flask, we found that the documentation was very poor and some 
behaviour was erratic. Also, creation and maintenance of the database was taking longer than previous 
web projects. 

As a group, we decided that it would be beneficial to switch technologies to Ruby on Rails, as we had
previous experience and was quicker to set up. We consulted with David in our weekly scrum, who was
happy for us to change. The change would not affect end users of the system, and would still enable us 
to develop in the same environments. 

\subsubsection{Back-end: Final Implementation - Ruby on Rails} \label{sec:impl_RoR}

We used our previous experience in Ruby on Rails to quickly and easily set up the project. We could also
use a wide range of gems for particular features, especially for authentication users with the college
Kerberos servers. Using rails also meant a smooth interaction with the database, which also required 
little setup. In the first few days of development we noticed that we were implementing features much
faster and feeling more confident with the work that lied ahead. 

The user hierarchy is underpinned by the well-known ``devise'' gem, which is extended by token and 
Kerberos authentication gems to make sure the application is secure. Authentication tokens for Imperial 
users are generated by the Kerberos gem authentication with the college servers, and are passed around 
by AngularJS. We also use the ``carrierwave'' gem to deal with uploading of visualisations. It allows us
to restrict file types and manages the storage of the files automatically, reducing our workload. 

\subsubsection{Playout Software}
Due to the cross-platform requirement of the playout software, we decided to explore two toolkit's which showed cross-platform functionality which Tim and Andrew had experience with, GTK and QT. We decided to write the software in Python, as the bindings for both toolkits appeared to be robust and well-maintained, we were quite familiar with Python, and for its ability to quickly write working prototypes.

Having experimented first with GTK3 on Windows, we found that it was not stable or robust enough, particularly when used with Webkit (to display the projected content) and finding that QT was in fact the opposite, we decided to proceed using PyQT.

The playout software is essentially multiple WebKit WebView's, stacked to match the display configuration provided (which matches and area on screen to a certain projector). It polls our main server, asking for which content should currently be shown and on which screens, and upon receiving this data, creates, resizes and positions the WebView's accordingly, pointing them to load the right content.

We chose this approach, instead of a simpler one, perhaps involving fully fledged web browsers, as it allows us to remove any UI chrome, which might reveal any implementation and hence provide a less-than-professional appearance. WebKit is also sufficiently mature and robust enough for us to rely upon it, and it provides a generous API so that we can make our application more intelligent (for example, only displaying new content once it has loaded in the WebView etc.)

\subsection{AppStore Implemetation}

\subsubsection{Architecture} 
lots TODO here

\begin{figure}[h!]
  \centering
    \includegraphics[width = 0.99\textwidth]{./impl/architecture.png}
  \caption{System architecture for the AppStore}
  \label{fig:impl_architecture}
\end{figure}

% Diagram on system architecture, showing RESTful API, HTML gets and playout software gets
% RoR enforces MVC architectural pattern

\subsubsection{Models}
As multiple team members were changing the structure of the models, we kept track of their fields
on the Gitlab Wiki page. 

\begin{figure}[h!]
  \centering
    \includegraphics[width = 0.99\textwidth]{./impl/models.png}
  \caption{Entity Relationship Diagram for models of entities and resources in system}
  \label{fig:impl_models}
\end{figure}

% Diagram for model relationship
% 1 or 2 paragraphs for each model - what it represents/does, relate to the objectives in section 1

\paragraph{User}
The user model represents those that submit and look at approved visualisations in the catalogue. 
Additionally, the \textbf{isAdmin} field allows us to check which users are allowed to moderate 
and schedule, after initially populating the database with a few administrators. 


\paragraph{Visualisation}
The visualisation model holds data about a submitted visualisation or advert. Although we have only used
one model, it is flexible enough to support multiple file types (including web links and no files at 
all). It is linked to a specific user and not displayed in the main program until it is approved by an 
administrator.


\begin{figure}[h!]
  \centering
    \includegraphics[width = 0.99\textwidth]{./relations/user-vis.png}
  \caption{One to many relationship between \textbf{User} and \textbf{Visualisation}. Created when 
  			user submits a visualisation and may be destroyed upon rejection by an administrator.}
  \label{fig:rel-user-vis}
\end{figure}




\paragraph{Comment}
The comment model is a basic structure to hold a textual comment on a particular visualisation. It 
belongs to one user and one visualisation. 

\begin{figure}[h!]
  \centering
    \includegraphics[width = 0.99\textwidth]{./relations/user-comment-vis.png}
  \caption{Diagram showing that a \textbf{User} has many \textbf{Comment}s, which belong to a unique
  			\textbf{Visualisation}. Comments are created on the particular visualisation's page and
  			linked with the current user via authentication tokens.}
  \label{fig:rel-user-comment-vis}
\end{figure}




\paragraph{Timeslot}
A timeslot represents a section of time created by the admin when scheduling. It is specific to a date,
and uniquely represented by a start time and end time using the Ruby ``date'' module. For robustness,
we have used the ISO 8601 format throughout the application for easy transformations and comparisons. A 
timeslot has many programmes that are to be displayed between the start and end times, according to our 
scheduling algorithm.


\paragraph{Programme}
The programme model is created when an admin is scheduling. It holds the number of screens that a 
visualisation is going to be displayed on and also the assigned priority, set by the admin. It is linked
with a single visualisation, but as one visualisation may be scheduled many times this is not a 
one-to-one relationship. Also, the programme is linked to a specific timeslot, as described below.

\begin{figure}[h!]
  \centering
    \includegraphics[width = 0.99\textwidth]{./relations/timeslot-programme-vis.png}
  \caption{One to many relationship between a \textbf{Timeslot}, created when scheduling, and a 
  			\textbf{Programme}, created when choosing a visualisation to be scheduled. Also shown is 
  			the many to one relationship between \textbf{Programme}s and \textbf{Visualisation}s.}
  \label{fig:rel-timeslot-programme-vis}
\end{figure}






\paragraph{Playout Session}
PlayoutSession records are generated solely by the scheduling algorithm. It describes when a 
visualisation is to be scheduled in a particular timeslot, including the screens it spans. A 
visualisation is displayed multiple times in a timeslot (in order to keep the screens interesting),
so the same visualisation will have multiple start and end times for a timeslot, with the start and
end screens also differing.

\begin{figure}[h!]
  \centering
    \includegraphics[width = 0.99\textwidth]{./relations/timeslot-ps-vis.png}
  \caption{After \textbf{Timeslot}s are passed to the scheduling algorithm, \textbf{PlayoutSession}s 
  			are produced, which have a many to one relationship with \textbf{Visualisation}s, as they
  			can be scheduled to be displayed mulitple times.}
  \label{fig:rel-timeslot-ps-vis}
\end{figure}






\subsubsection{Controller Actions}

% Briefly describe controller actions which requires routing, etc. - what it does 
Rails uses a Model-View-Controller (MVC) architecture, making it easy for communication between the 
server and browser and server and database. This meant that the server implementation boiled down to
writing controller actions for HTTP requests, along with some utility functions. We used JSON to 
communicate with the frontend - providing information from the database obtained with the built in 
ActiveRecord. These were separated so that a team member could be assigned to a particular action.   

% TODO: Andrew: is it worth to write a view section?
% \subsubsection{Views}


\subsubsection{Scheduling Library}

% TODO: Jackie: Brief mention of the library and the functions (high-level)

As the scheduling library was implemented separately from the request controllers,
we needed a middle-man to call the scheduling functions. When a timeslot is edited, i.e. 
visualisations/adverts where added to it, the scheduling function is called from
the controller and the playout session records are created in the database. Any 
subsequent changes to a timeslot clears the sessions that the scheduling algorithm 
has previously created for it, and generates a new schedule. 

\subsubsection{Playout Software}

% TODO: Working mechanism - how it grabs visualisation, rendering, QR...



\subsection{Technical Challenges \& Risks}

\subsubsection{Mastery of Implementation Tools}
During implementation, we have encountered quite a few bottlenecks when attempting
to master the tools to achieve our objectives.

\paragraph{Flask}
As mentioned previously, we encountered challenges when using Flask with Python for the backend to our 
project. We were challenged with poor documentation for addition modules and long setup times for 
trivial tasks. We addressed these by switching technologies to Ruby on Rails - with which we had 
previous experience. 

\paragraph{Docker}
We also had a few issues when using Docker containers, whereby data was not being saved to the database.
We assigned Bryan to work exclusively on Docker, while other members implemented features using dummy 
data. This resulted in a quick fix of the problem, and Bryan then briefed the group on how to implement
inside the Docker containers. 

\paragraph{Color-thief}
A small but intelligent feature of our webapp was to use colours in the frontend that are calculated 
from the uploaded visualisation screenshots - done via ``color-thief''. Originally this image
processing code was done on the client's side, but we noticed that it was computationally expensive,
breaking our fluid interface requirement. We moved this to the sever side code, where it was still 
affecting response times. After some research by Tom, we took advantage of Rails' thread safety to move
this image processing to a separate thread. Although this meant that these colours were not generated 
immediately, the nature of admin moderation meant that uploaded visualisations are very likely to be 
shown before this new thread finishes its work.

%TODO: Andrew + Emma, any probs and risks with frontned? 


\subsubsection{From Java Scheduling to Ruby Scheduling}
%  TODO: Translation on scheduling from Java to Ruby

We decided to use Java to initially write the scheduling algorithm, which would then be translated to 
Ruby. This was because we were more confident with Java, and it's object orientated paradigm would make 
the algorithm easier to implement. We thought (correctly) that this method would be quicker than
implementing the algorithm in Ruby from the outset. Intelligent design and use of comments meant that
the resulting Ruby code would be well structured and efficient.


\begin{figure}[h!]
  \begin{minipage}{0.49\textwidth}
%    \includegraphics[width = 0.99\textwidth]{./impl/java_scheduling.jpg}
  \end{minipage}
  \begin{minipage}{0.49\textwidth}
%    \includegraphics[width = 0.99\textwidth]{./impl/ruby_scheduling.jpg}
  \end{minipage}
    
  \caption{Implementing scheduling libarary in Java (left) and translation to Ruby (right)}
  \label{fig:impl_translation}
\end{figure}

\subsubsection{Mitigating Technical Risks}

% TODO: Any risks anticipated, and how mitigated

\paragraph{Cross Platform Usage}
We anticipated that the cross platform playout software requirement may cause issues due to Python
and/or Gtk versions on two different architectures. To mitigate this risk, we made sure to use dual-boot
machines with Windows and Linux (or virtual machines), and to test very frequently. We agreed that after
every small feature implemented, it would need to be tested on both platforms. This resulted in robust, 
cross-platform code.

\paragraph{User Access Control}
As our application has a small user hierarchy (with passers-by being users with no account at all!), we 
predicted that our app may show some information to inappropriate users. For example, we didn't want a 
non-admin user to access any non-approved visualisations. To remedy this, we conducted a full test of
our routing and API on the server, logged in as admins, non-admins, and not logged in at all. 

\paragraph{Date \& Time Handling}
As mentioned in the description of the models, we recognised that we would have a lot of work involving
dates and times. We did not want to waste processing power and introduce minor bugs due to 
discrepencies with dates. Due to Andrew's prior experience with using dates in applications, we decided 
to standardize dates in the ISO 8601 format. This meant we did not have to do any conversions or string
manipulations, and also to use Ruby's built-in functions in the \textit{datetime} module. 


\subsubsection{Security}
TODO: 
use tokens and boolean flag only set to true when we seed it 
test APIs 
make sure non-admins cannot moderate, schedule, see non-approved data



\subsection{Extensions}
% Proposal (Bryan): Move the QR Voting from conclusion to here


\newpage
\section{Evaluation}

\subsection{Product Requirement \& Stakeholder Relationships}

In the first week of embarking on our project, we met with our supervisor to highlight the initial 
components required. At first, these were general requirements including:

\begin{itemize}

  \item Stakeholder requirements resembling user stories (e.g. a user is allowed to submit scientific visualisations and/or advertisements, as well as to state his/her preference(s) on playout).

  \item System/Interface requirements - what users expect it to be able to do based on the user stories above (e.g. The scheduling system should schedule items to play out in rotation, so that passers-by will not be bored by the ``fixed" playout sessions).
\end{itemize}

In the following weeks, we then clarified and expanded on these requirements as a group. This allowed us to discuss the implementation and technical details of specific features.

\subsubsection{Value Proposition}

We also further clarified our understanding of stakeholders and how our system creates value for them via multiple value proposition canvasses. Figure \ref{fig:eval_valpropcanvas} shows the canvas for the Imperial Data Science Institute, which our supervisor is associated with. It includes a customer profile with a list of jobs, gains and pains, and corresponding products/services, gain creators and pain relievers (value map). The gains/pains of the institute, along with their creators/relievers are as follows:

\begin{figure}[h!]
   \begin{center}
      \includegraphics[width = 0.9\textwidth, trim = 1cm 6.5cm 1cm 4.5cm, clip]{./eval/value_prop_canvas.jpg}
   \end{center}
   \caption{Value proposition canvas for our client (Imperial Data Science Institute).}
   \label{fig:eval_valpropcanvas}
\end{figure}

\begin{itemize}

\item Gain
   \begin{itemize}
      \itemsep-2mm
      \item Makes the walkway more interesting (by showing visualisation to passers-by)
      \item Creates income opportunities (by showing adverts)
      \item Get the institute known by others (by showing scientific visualisation from the institute)
      \item Promote Data Science (by sharing visualisations)
   \end{itemize}

\item Pain
   \begin{itemize}
      \itemsep-2mm
      \item Requires a large number of visualisations (relieved by inviting users to submit visualisations)
      \item Attracts inappropriate submissions from users (relieved through admin moderation)
      \item Potentially inconvenient playout schedulling (relieved through automatic scheduling with minimal input)
   \end{itemize}
\end{itemize} 


The canvasses enable us to disregard features that deliver low or no value, and make more reasonable assumptions about our stakeholders. We believe that the latter has resulted in fewer problems for us when we began our product validation, detailed in Section \ref{sec:eval_validation}.




\subsubsection{Customer relationship}

Where customer relationships are concerned, we see our most important stakeholder, our supervisor, David, as somewhere between an internal and external customer, whom we hold weekly meetings and exchange emails frequently with but not contact in person daily. During weekly meetings, we explain the features that are in progress/to be done over the next week, so that David is always kept in the loop (Figure \ref{fig:eval_meetingboard}).

We tended to keep discussions fairly high-level, and only discussed implementation details/technologies when asked to do so, or when we felt that it was important to the discussion. We did this to mimic the scenario of David being our client, but also to ensure that discussions were not biased towards any kind of implementation, allowing us to fit our implementation around the best ideas, and not the other way around.

\begin{figure}[h!]
  \begin{subfigure}{0.5\textwidth}
    \centering
    \includegraphics[width = 0.9\textwidth, trim = 0 0.4cm 0 1.6cm, clip]{./eval/meeting-board2.jpg}
    \caption{After sprint cycle 2}
  \end{subfigure}
  \begin{subfigure}{0.5\textwidth}
    \centering
    \includegraphics[width = 0.9\textwidth, trim = 1.2cm 1.5cm 1.2cm 2.5cm, clip]{./eval/meeting-board.jpg}
    \caption{After sprint cycle 4}
  \end{subfigure}
  \caption{Meeting notes with group progress and feedback from David (our supervisor)}
  \label{fig:eval_meetingboard}
\end{figure}

Furthermore, with the aid of Jenkins, we are able to give the address of our ``release VM'' to David, where he can see the latest working version of the project. From this, David can constantly evaluate and provide feedback on our project features through all stages of development.

\subsubsection{Feedback handling}

Upon receiving feedback from our stakeholders, mainly from our supervisor, we handled them depending on their nature:

\begin{itemize}

  \item \textbf{Change in minor details of a feature/design:} \\
        Usually happening in the prototype stage, they include changing font size/colour and displaying some extra information on a screen. As these changes take only a few hours at most to implement, we took the majority of such suggestions and fitted these XS-items in the next iteration.

  \item \textbf{Introduction of new, peripheral features:} \\
        These include features that are related but not essential for our three main components (submission, moderation/scheduling and playout): Multiple default playout lists, playing videos with linked themes consecutively, buttons to copy and paste previous timeslots, etc. \\
        However, due to time limitations, we chose to integrate only one or two small-sized features into our planned implementation. The rest of the suggested features were put into an ``extra feature'' list, which we only considered implementing after basic versions of the main components are completed. This ensures that we can produce a minimal product at the very least before our planned deadline.

  \item \textbf{Major changes in feature implementation:} \\
        As a result of differing assumptions, the feedback necessitates the changing of what we have already implemented. For instance, we were required to change the priority rules in our scheduling algorithm. When this happens, we spend a significant portion of the weekly meeting to clarify the assumptions that our supervisor has made, and try to combine them with our own assumptions and implementations. This feedback has sometimes resulted in some or all of our code being scrapped, but it generates a product which is more useful to our stakeholders.

\end{itemize}

In all cases, we have communicated with the personnel that provided the
feedback with justification on our decisions. For example, we told
our supervisor that we are happy to accede to his request of adding a button which copies previous timeslots as we rate it as a S-sized task which can fit into the planned iteration, but his request for linked videos to be scheduled to be screened consecutively would delay our plans, and thus should be considered only after the entire system is implemented minimally.


\subsection{Task Management \& Team Progress}
During development, we constantly looked at the requirements from all of our stakeholders, which we stored in a shared document. In our weekly scrums, we presented the work that we have done to one another and discussed whether the project is on the right track. As discussed in section \ref{projman_tracking}, we actively use Trello, Facebook Messenger and GitLab (wiki and issues) to make sure that group members are implementing assigned tasks at the right times, and obtaining help from the correct member as soon as possible.

\subsubsection{Story Splitting}

While some of our project requirements can be completed within a few hours, other features are unlikely to be completed within one iteration. In such cases, we split the features into multiple units and implement them in different iterations based on their priority.

An example can be found in the following user story:
\begin{center}
``\textit{As a user, I want to access the platform via a set of credentials so that I can upload visualisations (user)/perform moderation and scheduling (administrator).}'' \\
\end{center}

We considered this task to be technically challenging. Hence, we split it into the following subtasks:

\begin{itemize}

  \item As an internal user (student/staff at Imperial), I want to access the platform via my college login so that I can upload/moderate and schedule visualisations without the need for an extra set of credentials.

  \item As an external user, I want to access the platform via some kind of access request system, so that I can share my visualisations too.

\end{itemize}

In addition to being reduced in size, splitting the story has also helped us further understand the needs of different groups of users. As such, we decided to implement the former requirement first, as some of our team members have had experience on working with the college login system, hence allowing the requirement to be fulfilled in a shorter time. The latter requirement was then scheduled to be carried out in parallel with the mentioned features.

\subsubsection{Spikes - Experiments with new technologies}

Throughout development, we also devoted a small proportion of time to experiment on technologies involved in later iterations. This allows us to better understand the potential complications that we will face and react accordingly.

While we planned to implement the playout system only in iterations 5 and 6 (the last two iterations), investigation on relevant technologies, including Qt and its adapters, were made from iteration 2. Preliminary research allowed us to confirm that 2 weeks would be a reasonable estimate in system implementation. Furthermore, we believe that the investigation would result in a more gentle learning curve, and reduces the risk for development grinding to a halt as team members will at least have some basic knowledge on Qt, and some code segments will be produced.

However, not all spikes bring good news - investigation on Kerberos login libraries has revealed that the adapter for Flask (with Python) is actually broken, forcing us to scrap the entire implementation. Nonetheless, the spike allowed us to switch our choice of development language early and avoid incurring high costs further into development.

\subsubsection{Project progress}
	
Quantitatively, we evaluated our project by tracking how fast we were ticking off our initial requirements. Using our Trello board and version control system, we can easily see by whom and at what time each feature has been implemented. By combining these with our estimates of the size of each task, we are able to analyse the group's performance via a Cumulative Flow Diagram (Figure \ref{fig:eval_cumuflow}).

\begin{figure}[h!]
  \centering
    \includegraphics[width = 0.99\textwidth]{./eval/cumu_flow.png}
  \caption{Cumulative flow diagram for our team based on tasks' status}
  \label{fig:eval_cumuflow}
\end{figure}

The diagram tracks the tasks on the columns ``To Do (This week)", ``In Progress" and ``Done", where each task carries a story point based on their size estimate. From the diagram, we can make the following observations:

\begin{enumerate}

  \item In the last week of October, the group did not make much headway for in-progress and to-do tasks. This observation is attributed to problems in setting up Jenkins, which caused a bottleneck in the entire development process.

  \item The lead time (time required between starting and completing a task) is usually around 2 weeks. Given the way we work on a new feature (2 cycles per feature - detailed in Section \ref{sec:uimockup}), we believe that we made healthy progress in getting individual components of our project done.

  \item Within the first 3 weeks in November, the team has completed tasks worth 35-40 story points. Given that the minimal system is estimated to be worth $\approx$90 story points, we believe that we will be able to meet our deadline in the second week of December with a similar effort.

\end{enumerate}

\subsection{Building the right thing - Assumption Validation} \label{sec:eval_validation}

As mentioned in Section \ref{sec:eval_validation}, obtaining feedback via mockups, prototypes with representative data and user testing allowed us to 'pivot' many times with minimal reimplementation overhead. It also allows us to identify problems or learn more about the issues that we are trying to solve, before we write large volumes of code which may end up to be not useful. Moreover, this lean approach \textbf{encourages us} to pivot more often, as there is no reason not to do so.

Given the tight deadlines for the entire project, we agreed to collect
user feedback as soon as the project commenced. This ensures that we are building the right product for our stakeholders.

\subsubsection{UI mockups/ prototypes} \label{sec:eval_uimockup}

Before implementing a particular part of our project, we begin with creating mockups (Figure \ref{fig:eval_mockup}). These can be produced in a relatively short time, and allows us to quickly think through the design of our project, without being tied down to any implementation details. After completion, we show the mockups to the main stakeholder in the project i.e. our supervisor, who gives us feedback. For example, he mentioned that it will be a good idea to show the priorities associated with each visualisation in the timeslot views, even if the visualisation is not selected after viewing the mockups.

Once we have settled on a general design, we complete the main implementation of the UI within that week's sprint cycle, but only up to the point where we can see how it will be used. As it is not interacting with the backend at this point, small changes are easily implemented, with the following week's sprint cycle involving ``hooking'' up this UI prototype with our backend.

We also made sure that this prototype is seeded with some dummy/representative data in some way, so that it is clear how each part of the project will operate in practice.

\begin{figure}[h!]
   \begin{center}
      \includegraphics[width = 0.9\textwidth, trim = 0 0 0 0cm, clip]{./eval/mockup.png}
   \end{center}
   \caption{Mockups on User Interface}
   \label{fig:eval_mockup}
\end{figure}

\subsubsection{Requirements on intangible ideas}

Compared to UIs which users can see and feel, we believed that uncovering the client's assumption on playout scheduling via mockups or prototypes will not be feasible as the scheduling algorithm is mainly rule-based. Instead, we delivered our ideas to our supervisore with whiteboard illustrations, and recorded his feedback.

Throughout these discussions, we uncovered several assumptions made by our supervisor, one of which is expecting the scheduling algorithm to ensure that playout time is directly proportional to metric set by administrators. In response, we have created additional unit tests to incorporate such requirements in our scheduling algorithm.

\begin{figure}[h!]
  \begin{minipage}{0.46\textwidth}
      \includegraphics[width = 0.99\textwidth, trim = 0 1cm 0 1.5cm, clip]{./eval/scheduling_whiteboard.jpg}
  \end{minipage}
  \begin{minipage}{0.53\textwidth}
      \includegraphics[width = 0.99\textwidth]{./eval/scheduling_spec.png}
  \end{minipage}
  \caption{Capturing scheduling requirements on whiteboard (left), \\ and subsequently via RSpec unit tests (right)}
  \label{fig:eval_scheduling}
\end{figure}

\subsubsection{User testing}

We also conducted implicit user tests during demonstrations of new features, where we asked our supervisor to complete certain tasks with minimal instructions and guidance (e.g. to navigate to the visualisation scheduling page and schedule some visualisations for playout).

Such testing allowed us to learn what is evident to us but obscure to our users. For example, in one of our demonstrations, we observed that our supervisor made multiple pauses when asked to navigate to the moderation and scheduling pages. This indicated that the icon showing the user menu may not be obvious enough to users, and the description for menu items may not be clear enough. Based on such observations, we changed the size of the ``show menu'' button, and also explored the effect of various font colours on the user menu.

We are planning to extend this user testing to include more potential users, especially those that are ranked second in our list of stakeholders, such as staff and students who may use the platform to submit and 
view visualisations.







\newpage
\section{Conclusion}

\subsection{Reflections}
%TODO: what would we have done differently, what did we learn?



\subsection{Future Extensions}

\subsubsection{QR Code Voting}
After presenting our progress to Prof. Yike Guo, he suggested that we add further interaction with 
passers-by on the Sherfield Walkway. To gauge interested, Prof. Guo said we could use Quick Response 
(QR) codes on the displayed visualisations, that a passer-by could scan if he/she liked the 
visualisation or advert being shown. This was not a feature we had though of before, but decided as a 
group that it would be quick enough to implement in the remaining time frame, and very beneficial to
the project. 

To generate the QR code in the playout software, we used a Python module recommened by lots of users 
online. In our database, we added a ``votes'' field to the visualisation model, and provided an API
for users to ``like'' them. When a user scanned a QR Code, they are directed to that visualisation in 
our application, and its vote field is incremented. As Andrew and Emma had been working to keep 
appropriate parts of the application mobile-friendly, this required no other implementation. To show 
popular visualisations, we added a button to order them by number of votes. This feature was also 
useful to an admin when scheduling, as he/she could see which adverts/visualisations are liked the 
most. 


\subsubsection{Social Sharing}
To expand interaction with external users, we could add social sharing technology to the 
visualisations. We identified a potential use case of a student seeing an advert for an event, and 
wanting to tell their friend via Facebook or Twitter. The QR codes could be expanded to take users to
a mobile-friendly page with buttons for sharing on various social networks. This could involve using 
the Facebook and Twitter API which are well documented and robust. 


\subsubsection{Mutiple Playback Systems}
In the final sprint cycle, David suggested a challenging but interesting extension. Although our 
playout software is cross platform, reproducible and customizable for different screen orientations, 
our webapp only allows for scheduling for one playout system at a time. 

Theoretically, if another instance of our server was run on a different machine, we could support 
multiple playout sessions. However, this is uneccessarily resource intensive. An useful extension 
therefore is to support multiple playout sessions with a single web application. This would involve 
implementing a more intelligent messaging interface between playout software and the server. In the 
front end we would need to separate playout software with a clear indication of what location is
being scheduled for. 


% ======================================
% ======================================
% ======================================

% -- Appendix
\newpage
\appendix

% -- Initial Spec
\section{(Initial) Specification for Visualisation Wall AppStore}

\textbf{\Large Introduction}

As part of the improvement plan in William Penney Building, windows facing the walkway will be replaced by floor-ceiling glass and projectors that will be internally mounted in WP (similar to that in DoC Teaching Lab). An AppStore system is required to accept upload from various parties and schedule them for playout, subject to moderation.\\

\textbf{\Large System Requirements} \vspace{5pt}

\textbf{\large General}

The system should interact with the following two type of personnel:

\begin{itemize}
  \item General user - who are allowed to submit scientific visualisation and/or advertisements, as well as to state preference on playout.
  \item Administrator - who are allowed to moderate submitted items and to set/override schedules for playout.
\end{itemize}

User hierarchy is not required, it is expected there will be not more than 2 administrators.\\

\textbf{\large Visualisation Submission}

The system should:

\begin{itemize}
\item Accept scientific visualisation, advertising material, events to be advertised (or equivalents) as uploads
\item (Minimally) accept uploads from parties with college login (inc. students, staff, societies)
\item (Ideally) accept uploads from the public (provided external parties has requested and given access to submission)
\item (Minimally) accept submissions of the format: JPEG/BMP/PDF Provide a combination of college login system and access request system as authentication/ authorisation
\item Host data in an internal (provided) cloudstack\\
\end{itemize}

\textbf{\large Moderation}

The system should allow administrators to moderate submitted visualisations (et. al.) - to approve or disapprove submissions.\\

\textbf{\large Scheduling and Playout}

The scheduling system should:

\begin{itemize}
\item Schedule items to play out in rotation (no requirement on scheduling algorithms)
\item Schedule scientific visualisation to play longer than advertisements (or equivalents)
\item Provide administrators ability to control visualisation scheduling (manual scheduling is expected to be conducted on weekly basis)
\item (Prefered) provide administrators options to override scheduled playouts - e.g. to display a specified item on top of other visualisations
\item Allow user to specify visualisation preference (but without control of schedules)
\end{itemize}

The playout system would comprise of:

\begin{itemize}
\item 4 HD Projected Screen - Landscape orientation (4:3 aspect ratio) - controlled by one machine 
\item (Optional) 84” 4K Multi-touch screen - controlled by another machine
\end{itemize}

The playout system would:

\begin{itemize}
\item Size visualisation (or equivalents) automatically (e.g. scale fluidly) (Highly possibly) be web-based and playout via browsers
\item Be run from 8am - 8pm (but should be built to run arbitrary hours)
\item Be scalable in projecting on screens (e.g. 4x1 or 2x2 configuration)\\
\end{itemize}

\textbf{\large Security}

The system should be secure from external interference, especially for playouts.\\

\textbf{\large Miscellaneous}

\begin{itemize}
\item The system should provide an RESTful API for third-party upload/ playout.
Development standards/requirements are welcomed for visualisation, but should be kept minimal for general web pages be shown
\item The system should be branded under Imperial’s Data Science Institute\\
\end{itemize}


\textbf{\Large Available Technologies/ Resources} \vspace{5pt}

\textbf{\large 4x HD Projection Screen}

Screens are controlled by a single, custom machine with graphics card via HDMI cables. It is believed that Windows provide better driver support yet it is fine to run on Linux as long as Chrome is able to be run.\\

\textbf{\large 84” 4K Multi-touch Screen}

The multi-touch screen is run by a dedicated machine in Windows, which the touch screen driver is based on.\\

\textbf{\large Cloudstack/ Virtual Machine}

The system is expected to run on a virtual cloudstack. Virtual machine preinstalled with Windows Server 2008/ Linux Server is available with SQL Instances, Python, PHP, etc. VM can be access remotely (e.g. via linux kernel).\\
% ---

\end{document}
